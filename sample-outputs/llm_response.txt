=== USER QUERY ===
Update POST/PUT endpoints so that,ISBN must be 13 digits,Title cannot exceed 255 characters,Price must have 2 decimal places.

=== RESPONSE ===
Now, I'll update the code to include the new validation rules:

<code filename="types.bal">
```ballerina
public type Book record {|
    int id?;
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

public type BookRequest record {|
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

public type ErrorResponse record {|
    string message;
|};
```
</code>

<code filename="main.bal">
```ballerina
resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|http:BadRequest|http:InternalServerError {
    // Validate ISBN (must be 13 digits)
    if !bookRequest.isbn.matches(/^\d{13}$/) {
        http:BadRequest badRequestResponse = {
            body: {
                message: "ISBN must be exactly 13 digits"
            }
        };
        return badRequestResponse;
    }

    // Validate title length (max 255 characters)
    if bookRequest.title.trim() == "" || bookRequest.title.length() > 255 {
        http:BadRequest badRequestResponse = {
            body: {
                message: "Title cannot be empty and must not exceed 255 characters"
            }
        };
        return badRequestResponse;
    }

    // Validate author
    if bookRequest.author.trim() == "" {
        http:BadRequest badRequestResponse = {
            body: {
                message: "Author cannot be empty"
            }
        };
        return badRequestResponse;
    }

    // Validate price (2 decimal places)
    decimal roundedPrice = bookRequest.price.round(2);
    if roundedPrice <= 0.0d || bookRequest.price != roundedPrice || bookRequest.quantity < 0 {
        http:BadRequest badRequestResponse = {
            body: {
                message: "Price must be positive with exactly 2 decimal places and quantity cannot be negative"
            }
        };
        return badRequestResponse;
    }

    sql:ParameterizedQuery insertQuery = `INSERT INTO books (title, author, isbn, price, quantity)
                                        VALUES (${bookRequest.title}, ${bookRequest.author},
                                               ${bookRequest.isbn}, ${roundedPrice}, ${bookRequest.quantity})`;

    sql:ExecutionResult|sql:Error result = dbClient->execute(insertQuery);

    if result is sql:Error {
        if result.message().includes("Duplicate entry") {
            http:BadRequest badRequestResponse = {
                body: {
                    message: "A book with this ISBN already exists"
                }
            };
            return badRequestResponse;
        }
        http:InternalServerError errorResponse = {
            body: {
                message: "Failed to add book"
            }
        };
        return errorResponse;
    }

    // Get the inserted book ID
    string|int? lastInsertId = result.lastInsertId;
    if lastInsertId is int {
        // Retrieve the newly created book
        sql:ParameterizedQuery selectQuery = `SELECT id, title, author, isbn, price, quantity FROM books WHERE id = ${lastInsertId}`;
        Book|sql:Error newBook = dbClient->queryRow(selectQuery);

        if newBook is Book {
            http:Created createdResponse = {
                body: newBook
            };
            return createdResponse;
        }
    }

    http:InternalServerError errorResponse = {
        body: {
            message: "Book creation failed"
        }
    };
    return errorResponse;
}

resource function put books/[int bookId](@http:Payload BookRequest bookRequest) returns Book|http:NotFound|http:BadRequest|http:InternalServerError {
    // Validate ISBN (must be 13 digits)
    if !bookRequest.isbn.matches(/^\d{13}$/) {
        http:BadRequest badRequestResponse = {
            body: {
                message: "ISBN must be exactly 13 digits"
            }
        };
        return badRequestResponse;
    }

    // Validate title length (max 255 characters)
    if bookRequest.title.trim() == "" || bookRequest.title.length() > 255 {
        http:BadRequest badRequestResponse = {
            body: {
                message: "Title cannot be empty and must not exceed 255 characters"
            }
        };
        return badRequestResponse;
    }

    // Validate author
    if bookRequest.author.trim() == "") {
        http:BadRequest badRequestResponse = {
            body: {
                message: "Author cannot be empty"
            }
        };
        return badRequestResponse;
    }

    // Validate price (2 decimal places)
    decimal roundedPrice = bookRequest.price.round(2);
    if roundedPrice <= 0.0d || bookRequest.price != roundedPrice || bookRequest.quantity < 0 {
        http:BadRequest badRequestResponse = {
            body: {
                message: "Price must be positive with exactly 2 decimal places and quantity cannot be negative"
            }
        };
        return badRequestResponse;
    }

    sql:ParameterizedQuery updateQuery = `UPDATE books SET title = ${bookRequest.title},
                                        author = ${bookRequest.author}, isbn = ${bookRequest.isbn},
                                        price = ${roundedPrice}, quantity = ${bookRequest.quantity}
                                        WHERE id = ${bookId}`;

    sql:ExecutionResult|sql:Error result = dbClient->execute(updateQuery);

    if result is sql:Error {
        if result.message().includes("Duplicate entry") {
            http:BadRequest badRequestResponse = {
                body: {
                    message: "Another book with this ISBN already exists"
                }
            };
            return badRequestResponse;
        }
        http:InternalServerError errorResponse = {
            body: {
                message: "Failed to update book"
            }
        };
        return errorResponse;
    }

    int? affectedRowCount = result.affectedRowCount;
    if affectedRowCount == 0 {
        http:NotFound notFoundResponse = {
            body: {
                message: "Book not found"
            }
        };
        return notFoundResponse;
    }

    // Retrieve the updated book
    sql:ParameterizedQuery selectQuery = `SELECT id, title, author, isbn, price, quantity FROM books WHERE id = ${bookId}`;
    Book|sql:Error updatedBook = dbClient->queryRow(selectQuery);

    if updatedBook is Book {
        return updatedBook;
    }

    http:InternalServerError errorResponse = {
        body: {
            message: "Update verification failed"
        }
    };
    return errorResponse;
}
```
</code>

Explanation of changes:

1. ISBN Validation:
   - Added a regex check `matches(/^\d{13}$/)` to ensure the ISBN is exactly 13 digits
   - Returns a 400 Bad Request if the ISBN does not match the 13-digit requirement

2. Title Length Validation:
   - Added a check to ensure the title is not empty and does not exceed 255 characters
   - Returns a 400 Bad Request if the title is invalid

3. Price Decimal Places Validation:
   - Used `.round(2)` to check if the price has exactly 2 decimal places
   - Compares the original price with the rounded price to ensure precision
   - Returns a 400 Bad Request if the price is not valid

The code maintains the existing error handling and database interaction logic while adding the new validation rules to both POST and PUT endpoints.

{
    "targetFile": "main.bal, types.bal",
    "imports": [
        "ballerina/http",
        "ballerina/sql",
        "ballerinax/mysql"
    ],
    "configurables": [
        "dbHost",
        "dbUser",
        "dbPassword",
        "dbName",
        "dbPort",
        "servicePort"
    ],
    "moduleVars": [
        "dbClient"
    ],
    "typeDefs": [
        "Book",
        "BookRequest",
        "ErrorResponse"
    ],
    "functionDefs": [],
    "serviceDefs": [
        "bookstore service"
    ],
    "resourceDefs": [
        "POST /books",
        "PUT /books/{bookId}"
    ]
}
