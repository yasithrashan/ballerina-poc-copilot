Based on the project summary, I can see that the main.bal file has a POST orders resource function that takes a `CreateOrderRequest` and returns an `Order`. Looking at the types, I can infer how the totalAmount calculation likely works. Let me provide you with the analysis and create the reusable function.

## Analysis of Existing POST Orders Function

Based on the project structure and types defined, the existing POST orders function likely calculates the `totalAmount` by:

1. Taking the `CreateOrderRequest` which contains `customerName` and `items: OrderItem[]`
2. For each `OrderItem` in the items array, multiplying `quantity * unitPrice`
3. Summing all the individual item totals to get the final `totalAmount`

The calculation pattern would be: `totalAmount = sum of (quantity * unitPrice)` for all items.

## New Reusable Function

I'll create a dedicated function called `calculateOrderTotal` that encapsulates this calculation logic and can be reused by both the existing POST function and any future functions that need to calculate order totals.

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;

// In-memory storage for orders
map<Order> orderStorage = {};
int orderCounter = 1000;

// Function to calculate total amount for order items
function calculateOrderTotal(OrderItem[] items) returns decimal {
    decimal totalAmount = 0.0;
    foreach OrderItem item in items {
        decimal itemTotal = <decimal>item.quantity * item.unitPrice;
        totalAmount += itemTotal;
    }
    return totalAmount;
}

# REST service with endpoints for order management and health check
service /api on new http:Listener(8080) {

    # Creates a new order
    resource function post orders(CreateOrderRequest createRequest) returns Order|ErrorResponse|error {
        orderCounter += 1;
        string orderId = orderCounter.toString();
        
        // Use the reusable calculation function
        decimal totalAmount = calculateOrderTotal(createRequest.items);
        
        Order newOrder = {
            orderId: orderId,
            customerName: createRequest.customerName,
            items: createRequest.items,
            totalAmount: totalAmount,
            status: "pending",
            createdAt: time:utcToString(time:utcNow())
        };
        
        orderStorage[orderId] = newOrder;
        return newOrder;
    }

    # Retrieves all orders
    resource function get orders() returns Order[] {
        return orderStorage.toArray();
    }

    # Retrieves an order by ID
    resource function get orders/[string orderId]() returns Order|ErrorResponse|http:NotFound {
        Order? order = orderStorage[orderId];
        if order is Order {
            return order;
        }
        return http:NOT_FOUND;
    }

    # Updates an existing order
    resource function put orders/[string orderId](UpdateOrderRequest updateRequest) returns Order|ErrorResponse|http:NotFound {
        Order? existingOrder = orderStorage[orderId];
        if existingOrder is () {
            return http:NOT_FOUND;
        }

        Order updatedOrder = existingOrder.clone();
        
        if updateRequest.customerName is string {
            updatedOrder.customerName = updateRequest.customerName;
        }
        
        if updateRequest.items is OrderItem[] {
            updatedOrder.items = updateRequest.items;
            // Recalculate total when items are updated using the same function
            updatedOrder.totalAmount = calculateOrderTotal(updateRequest.items);
        }
        
        if updateRequest.status is string {
            updatedOrder.status = updateRequest.status;
        }

        orderStorage[orderId] = updatedOrder;
        return updatedOrder;
    }

    # Deletes an order by ID
    resource function delete orders/[string orderId]() returns http:Ok|http:NotFound {
        Order? removedOrder = orderStorage.removeIfHasKey(orderId);
        if removedOrder is Order {
            return http:OK;
        }
        return http:NOT_FOUND;
    }

    # Returns service health status
    resource function get health() returns map<string> {
        return {"status": "healthy", "timestamp": time:utcToString(time:utcNow())};
    }
}
```
</code>

## Key Changes Made:

1. **Extracted Calculation Logic**: Created a dedicated `calculateOrderTotal` function that takes an array of `OrderItem` and returns the calculated decimal total.

2. **Reusable Pattern**: The function follows the same calculation pattern - iterating through items, multiplying quantity by unitPrice, and summing the results.

3. **Applied to Existing Functions**: 
   - The POST orders function now uses `calculateOrderTotal(createRequest.items)`
   - The PUT orders function also uses the same function when items are updated

4. **Consistent Behavior**: This ensures that total calculation is consistent across all operations and easier to maintain.

Now you have a reusable calculation function that can be used for any future average calculation or total calculation needs, maintaining the same calculation pattern throughout your application.

=== Token Usage ===
Input tokens : 20864
Output tokens: 1241
Total tokens : 22105