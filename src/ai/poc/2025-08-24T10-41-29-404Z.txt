Based on the project summary in bal.md, I can see the structure of the existing codebase. Let me analyze the existing POST orders function and create a new function that reuses the totalAmount calculation pattern.

## Analysis of Existing totalAmount Calculation

From the project summary, I can see that the POST orders resource function takes a `CreateOrderRequest` parameter which contains:
- `customerName: string`
- `items: OrderItem[]`

Each `OrderItem` has:
- `itemName: string`
- `quantity: int` 
- `unitPrice: decimal`

The typical pattern for calculating totalAmount would be to iterate through all items and sum up `quantity * unitPrice` for each item.

## Solution

I'll create a utility function that extracts this calculation logic so it can be reused. This function will take an array of OrderItems and return the calculated total amount.

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;

// In-memory storage for orders
map<Order> orderStorage = {};
int orderCounter = 1000;

// Utility function to calculate total amount from order items
function calculateTotalAmount(OrderItem[] items) returns decimal {
    decimal totalAmount = 0.0;
    foreach OrderItem item in items {
        decimal itemTotal = <decimal>item.quantity * item.unitPrice;
        totalAmount += itemTotal;
    }
    return totalAmount;
}

// REST service with endpoints for order management and health check
service /api on new http:Listener(8080) {

    // Creates a new order
    resource function post orders(CreateOrderRequest createRequest) returns Order|ErrorResponse|error {
        // Generate new order ID
        orderCounter += 1;
        string orderId = orderCounter.toString();
        
        // Calculate total amount using the utility function
        decimal totalAmount = calculateTotalAmount(createRequest.items);
        
        // Create order with current timestamp
        Order newOrder = {
            orderId: orderId,
            customerName: createRequest.customerName,
            items: createRequest.items,
            totalAmount: totalAmount,
            status: "pending",
            createdAt: time:utcToString(time:utcNow())
        };
        
        // Store the order
        orderStorage[orderId] = newOrder;
        
        return newOrder;
    }

    // Retrieves all orders
    resource function get orders() returns Order[] {
        return orderStorage.toArray();
    }

    // Retrieves an order by ID
    resource function get orders/[string orderId]() returns Order|ErrorResponse|http:NotFound {
        if orderStorage.hasKey(key = orderId) {
            Order retrievedOrder = orderStorage.get(orderId);
            return retrievedOrder;
        }
        return http:NOT_FOUND;
    }

    // Updates an existing order
    resource function put orders/[string orderId](UpdateOrderRequest updateRequest) returns Order|ErrorResponse|http:NotFound {
        if !orderStorage.hasKey(key = orderId) {
            return http:NOT_FOUND;
        }
        
        Order existingOrder = orderStorage.get(orderId);
        
        // Update fields if provided
        string updatedCustomerName = updateRequest.customerName ?: existingOrder.customerName;
        OrderItem[] updatedItems = updateRequest.items ?: existingOrder.items;
        string updatedStatus = updateRequest.status ?: existingOrder.status;
        
        // Recalculate total amount using the utility function if items changed
        decimal updatedTotalAmount = calculateTotalAmount(updatedItems);
        
        Order updatedOrder = {
            orderId: orderId,
            customerName: updatedCustomerName,
            items: updatedItems,
            totalAmount: updatedTotalAmount,
            status: updatedStatus,
            createdAt: existingOrder.createdAt
        };
        
        orderStorage[orderId] = updatedOrder;
        return updatedOrder;
    }

    // Deletes an order by ID
    resource function delete orders/[string orderId]() returns http:Ok|http:NotFound {
        if orderStorage.hasKey(key = orderId) {
            Order removedOrder = orderStorage.remove(orderId);
            return http:OK;
        }
        return http:NOT_FOUND;
    }

    // Returns service health status
    resource function get health() returns map<string> {
        return {
            "status": "healthy",
            "timestamp": time:utcToString(time:utcNow())
        };
    }
}
```
</code>

## Explanation

I've created a new utility function `calculateTotalAmount(OrderItem[] items)` that:

1. **Extracts the calculation logic**: Takes an array of OrderItems and calculates the total amount
2. **Reuses the same pattern**: Iterates through each item and multiplies `quantity * unitPrice`
3. **Returns a decimal**: Provides the calculated total amount that can be used anywhere

The function is now used in two places:
1. **POST orders**: When creating a new order, it calculates the initial total amount
2. **PUT orders**: When updating an order with new items, it recalculates the total amount

This approach follows the DRY (Don't Repeat Yourself) principle and makes the code more maintainable. If you need to change how totals are calculated (e.g., adding taxes or discounts), you only need to modify the `calculateTotalAmount` function.

=== Token Usage ===
Input tokens : 20985
Output tokens: 1327
Total tokens : 22312