=== USER QUERY ===
when creating a new order add user email as a for new feature

=== RESPONSE ===
Based on the project summary and the AST information, I can see the current structure. To add user email as a new feature when creating orders, I need to:

1. **Add email field to the CreateOrderRequest record** - This will allow clients to provide an email when creating an order
2. **Add email field to the Order record** - This will store the email in the order data
3. **Update the order creation logic** - The resource function will handle the new email field

## Explanation

The control flow will remain the same, but with the email enhancement:

1. **Client sends POST request** to `/api/orders` with order data including the new email field
2. **CreateOrderRequest record** now captures the email along with customerName and items
3. **Order creation logic** generates a new order ID, calculates total amount, sets initial status, timestamps, and now includes the email
4. **Order record** stores all order information including the email field
5. **Response** returns the complete order with the email included

The selected libraries remain the same:
- **ballerina/http** - For the REST service functionality
- **ballerina/time** - For timestamp generation

No additional libraries are needed since email is just a string field that will be stored and returned with the order data.

<code filename="types.bal">
```ballerina
// Order item details
public type OrderItem record {
    string itemName;
    int quantity;
    decimal unitPrice;
};

// Order record with email field added
public type Order record {
    string orderId;
    string customerName;
    string customerEmail;  // New email field
    OrderItem[] items;
    decimal totalAmount;
    string status;
    string createdAt;
};

// Create order request with email field added
public type CreateOrderRequest record {
    string customerName;
    string customerEmail;  // New email field
    OrderItem[] items;
};

// Update order request with optional email field
public type UpdateOrderRequest record {
    string? customerName;
    string? customerEmail;  // New optional email field
    OrderItem[]? items;
    string? status;
};

// Error response type
public type ErrorResponse record {
    string message;
    string 'error;
};
```
</code>

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;

// In-memory storage for orders
map<Order> orderStorage = {};

// Counter for generating order IDs
int orderCounter = 1000;

// REST service for order management
service /api on new http:Listener(8080) {

    // Creates a new order with email field
    resource function post orders(CreateOrderRequest createRequest) returns Order|ErrorResponse|error {
        
        // Validate required fields
        if createRequest.customerName.trim().length() == 0 {
            return {
                message: "Customer name is required",
                'error: "INVALID_INPUT"
            };
        }

        if createRequest.customerEmail.trim().length() == 0 {
            return {
                message: "Customer email is required",
                'error: "INVALID_INPUT"
            };
        }

        if createRequest.items.length() == 0 {
            return {
                message: "At least one item is required",
                'error: "INVALID_INPUT"
            };
        }

        // Calculate total amount
        decimal totalAmount = 0.0;
        foreach OrderItem item in createRequest.items {
            if item.quantity <= 0 || item.unitPrice < 0.0 {
                return {
                    message: "Invalid item quantity or price",
                    'error: "INVALID_INPUT"
                };
            }
            totalAmount += <decimal>item.quantity * item.unitPrice;
        }

        // Generate new order ID
        orderCounter += 1;
        string orderId = "ORD-" + orderCounter.toString();

        // Get current timestamp
        time:Utc currentTime = time:utcNow();
        string createdAt = time:utcToString(currentTime);

        // Create new order with email
        Order newOrder = {
            orderId: orderId,
            customerName: createRequest.customerName,
            customerEmail: createRequest.customerEmail,  // Include email
            items: createRequest.items,
            totalAmount: totalAmount,
            status: "PENDING",
            createdAt: createdAt
        };

        // Store the order
        orderStorage[orderId] = newOrder;

        return newOrder;
    }

    // Retrieves all orders
    resource function get orders() returns Order[] {
        return orderStorage.toArray();
    }

    // Retrieves an order by ID
    resource function get orders/[string orderId](string orderId) returns Order|ErrorResponse|http:NotFound {
        if orderStorage.hasKey(key = orderId) {
            Order order = orderStorage.get(orderId);
            return order;
        }
        return http:NOT_FOUND;
    }

    // Updates an existing order with optional email update
    resource function put orders/[string orderId](string orderId, UpdateOrderRequest updateRequest) returns Order|ErrorResponse|http:NotFound {
        if !orderStorage.hasKey(key = orderId) {
            return http:NOT_FOUND;
        }

        Order existingOrder = orderStorage.get(orderId);

        // Update fields if provided
        if updateRequest.customerName is string {
            string customerName = updateRequest.customerName;
            if customerName.trim().length() == 0 {
                return {
                    message: "Customer name cannot be empty",
                    'error: "INVALID_INPUT"
                };
            }
            existingOrder.customerName = customerName;
        }

        // Update email if provided
        if updateRequest.customerEmail is string {
            string customerEmail = updateRequest.customerEmail;
            if customerEmail.trim().length() == 0 {
                return {
                    message: "Customer email cannot be empty",
                    'error: "INVALID_INPUT"
                };
            }
            existingOrder.customerEmail = customerEmail;
        }

        if updateRequest.items is OrderItem[] {
            OrderItem[] items = updateRequest.items;
            if items.length() == 0 {
                return {
                    message: "At least one item is required",
                    'error: "INVALID_INPUT"
                };
            }

            // Recalculate total amount
            decimal totalAmount = 0.0;
            foreach OrderItem item in items {
                if item.quantity <= 0 || item.unitPrice < 0.0 {
                    return {
                        message: "Invalid item quantity or price",
                        'error: "INVALID_INPUT"
                    };
                }
                totalAmount += <decimal>item.quantity * item.unitPrice;
            }
            
            existingOrder.items = items;
            existingOrder.totalAmount = totalAmount;
        }

        if updateRequest.status is string {
            existingOrder.status = updateRequest.status;
        }

        // Update the order in storage
        orderStorage[orderId] = existingOrder;

        return existingOrder;
    }

    // Deletes an order by ID
    resource function delete orders/[string orderId](string orderId) returns http:Ok|http:NotFound {
        if orderStorage.hasKey(key = orderId) {
            Order removedOrder = orderStorage.remove(orderId);
            return http:OK;
        }
        return http:NOT_FOUND;
    }

    // Returns service health status
    resource function get health() returns map<string> {
        return {
            "status": "UP",
            "timestamp": time:utcToString(time:utcNow())
        };
    }
}
```
</code>

=== Token Usage ===
Input tokens : 21218
Output tokens: 1896
Total tokens : 23114