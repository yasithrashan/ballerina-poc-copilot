=== USER QUERY ===
when creating a new order add user email as a for new feature

=== RESPONSE ===
Based on the project summary and the type definitions, I can see the current structure. To add user email as a new feature for order creation, I need to:

1. Update the `CreateOrderRequest` type to include an email field
2. Update the `Order` type to include an email field  
3. Modify the order creation logic to handle the email field

## Explanation

I'll enhance the order management system by adding email functionality to the order creation process. The changes will involve:

**Control Flow:**
1. **Type Updates**: Modify the `CreateOrderRequest` record to include a mandatory `customerEmail` field and update the `Order` record to store the customer email
2. **Order Creation**: When a POST request is made to `/api/orders`, the system will now capture and store the customer's email along with other order details
3. **Data Storage**: The email will be persisted with the order in the in-memory storage

**Libraries Used:**
- The existing HTTP service framework will continue to handle REST endpoints
- No additional libraries are needed for this feature as it's a simple field addition

The email field will be mandatory in the create request to ensure we always have customer contact information for new orders.

<code filename="types.bal">
```ballerina
// Order item details
public type OrderItem record {
    string itemName;
    int quantity;
    decimal unitPrice;
};

// Complete order information
public type Order record {
    string orderId;
    string customerName;
    string customerEmail;
    OrderItem[] items;
    decimal totalAmount;
    string status;
    string createdAt;
};

// Request payload for creating a new order
public type CreateOrderRequest record {
    string customerName;
    string customerEmail;
    OrderItem[] items;
};

// Request payload for updating an existing order
public type UpdateOrderRequest record {
    string? customerName;
    string? customerEmail;
    OrderItem[]? items;
    string? status;
};

// Error response format
public type ErrorResponse record {
    string message;
    string 'error;
};
```
</code>

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;

// In-memory storage for orders
map<Order> orderStorage = {};
int orderCounter = 1000;

// REST service with endpoints for order management and health check
service /api on new http:Listener(8080) {

    // Creates a new order
    resource function post orders(CreateOrderRequest createRequest) returns Order|ErrorResponse|error {
        
        // Validate required fields
        if createRequest.customerName.trim() == "" {
            return {
                message: "Customer name is required",
                'error: "VALIDATION_ERROR"
            };
        }
        
        if createRequest.customerEmail.trim() == "" {
            return {
                message: "Customer email is required",
                'error: "VALIDATION_ERROR"
            };
        }
        
        if createRequest.items.length() == 0 {
            return {
                message: "At least one item is required",
                'error: "VALIDATION_ERROR"
            };
        }

        // Generate new order ID
        orderCounter += 1;
        string newOrderId = orderCounter.toString();
        
        // Calculate total amount
        decimal totalAmount = 0;
        foreach OrderItem item in createRequest.items {
            totalAmount += item.quantity * item.unitPrice;
        }
        
        // Create new order
        Order newOrder = {
            orderId: newOrderId,
            customerName: createRequest.customerName,
            customerEmail: createRequest.customerEmail,
            items: createRequest.items,
            totalAmount: totalAmount,
            status: "PENDING",
            createdAt: time:utcToString(time:utcNow())
        };
        
        // Store the order
        orderStorage[newOrderId] = newOrder;
        
        return newOrder;
    }

    // Retrieves all orders
    resource function get orders() returns Order[] {
        return orderStorage.toArray();
    }

    // Retrieves an order by ID
    resource function get orders/[string orderId]() returns Order|ErrorResponse|http:NotFound {
        Order? orderResult = orderStorage[orderId];
        if orderResult is Order {
            return orderResult;
        } else {
            return http:NOT_FOUND;
        }
    }

    // Updates an existing order
    resource function put orders/[string orderId](UpdateOrderRequest updateRequest) returns Order|ErrorResponse|http:NotFound {
        Order? existingOrder = orderStorage[orderId];
        
        if existingOrder is () {
            return http:NOT_FOUND;
        }
        
        // Update fields if provided
        Order updatedOrder = existingOrder.clone();
        
        if updateRequest.customerName is string {
            string customerName = updateRequest.customerName;
            if customerName.trim() != "" {
                updatedOrder.customerName = customerName;
            }
        }
        
        if updateRequest.customerEmail is string {
            string customerEmail = updateRequest.customerEmail;
            if customerEmail.trim() != "" {
                updatedOrder.customerEmail = customerEmail;
            }
        }
        
        if updateRequest.items is OrderItem[] {
            OrderItem[] items = updateRequest.items;
            updatedOrder.items = items;
            
            // Recalculate total amount
            decimal totalAmount = 0;
            foreach OrderItem item in items {
                totalAmount += item.quantity * item.unitPrice;
            }
            updatedOrder.totalAmount = totalAmount;
        }
        
        if updateRequest.status is string {
            string status = updateRequest.status;
            updatedOrder.status = status;
        }
        
        // Store updated order
        orderStorage[orderId] = updatedOrder;
        
        return updatedOrder;
    }

    // Deletes an order by ID
    resource function delete orders/[string orderId]() returns http:Ok|http:NotFound {
        if orderStorage.hasKey(orderId) {
            _ = orderStorage.remove(orderId);
            return http:OK;
        } else {
            return http:NOT_FOUND;
        }
    }

    // Returns service health status
    resource function get health() returns map<string> {
        return {
            "status": "UP",
            "timestamp": time:utcToString(time:utcNow())
        };
    }
}
```
</code>

=== Token Usage ===
Input tokens : 18096
Output tokens: 1578
Total tokens : 19674